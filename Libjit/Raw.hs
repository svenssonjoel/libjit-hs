-- GENERATED by C->Haskell Compiler, version 0.16.3 Crystal Seed, 24 Jan 2009 (Haskell)
-- Edit the ORIGNAL .chs file instead!


{-# LINE 1 "Libjit/Raw.chs" #-}

{-# LANGUAGE ForeignFunctionInterface,
             DeriveDataTypeable #-} 


module Libjit.Raw  where 

import Foreign.Ptr
import Foreign.ForeignPtr 
import Foreign.Storable
import Foreign.C.Types
import Foreign.C.String
import Foreign.Marshal.Array

import Data.Word
import Data.Typeable
import Data.Bits

import Control.Exception
import Control.Monad

import System.IO.Unsafe


----------------------------------------------------------------------------
-- Types
----------------------------------------------------------------------------
newtype Context  = Context {fromContext :: Ptr ()} 
newtype Type     = Type {fromType :: Ptr ()} 
newtype Function = Function {fromFunction :: Ptr ()}
newtype Value    = Value {fromValue :: Ptr ()}
newtype Block    = Block {fromBlock :: Ptr ()} 

-- Label is different from most other libjit types.
--  Label is an unsigned long  in C.
--  Labels seems to be passed by reference to most functions.
--  TODO: Will this be correct or do I need something else
--        Top ensure that the label is not "freed" while
--        still needed by libjit 
newtype Label    = Label (ForeignPtr CULong)
fromLabel (Label fptr) = unsafeForeignPtrToPtr fptr 
----------------------------------------------------------------------------
-- Helpers
----------------------------------------------------------------------------
withTypeArray  inp = withArray (fmap fromType inp)
withValueArray inp = withArray (fmap fromValue inp)

cFromEnum :: (Enum a, Integral i) => a -> i
cFromEnum = fromIntegral . fromEnum

cFromInt :: (Integral a, Integral b) => a -> b 
cFromInt = fromIntegral

fromFunPtr = castFunPtrToPtr 

intToBool i =  if i == 1 then True else False 
  
----------------------------------------------------------------------------
-- Exceptions
----------------------------------------------------------------------------
data LIBJITException = LIBJITException (Maybe Int) String
                    deriving (Eq, Show,Typeable) 

instance Exception LIBJITException

throwRaw :: String -> Ptr () -> IO ()
throwRaw str ptr =
  do
    when (nullPtr == ptr)
      $ throwIO (LIBJITException Nothing str)

throwOnBadValue :: Value -> IO Value 
throwOnBadValue v = throwRaw "Value is null" (fromValue v) >> return v

throwOnBadFunction :: Function -> IO Function
throwOnBadFunction f = throwRaw "Function is null" (fromFunction f) >> return f 

throwOnBadContext c = throwRaw "Context is null" (fromContext c) >> return c 
                    
-- Libjit uses the dotNET,dotGNU,windows tradition
-- of having 1 = Success 
--           0 = Failure
throwOnError :: Int -> IO ()
throwOnError i =
  do
    when (i /= 1)
      $ throwIO (LIBJITException (Just i) "Returned error code")

checkedValue v = throwOnBadValue (Value v)
----------------------------------------------------------------------------
-- Enums 
----------------------------------------------------------------------------


data ABI = CDECL
         | VARARG
         | STDCALL
         | FASTCALL
         deriving (Enum)

{-# LINE 100 "Libjit/Raw.chs" #-}

-- These are just defines in the C library.
 

data CallFlag = CallNothrow
              | CallNoreturn
              | CallTail
              deriving (Eq,Show)
instance Enum CallFlag where
  fromEnum CallNothrow = 1
  fromEnum CallNoreturn = 2
  fromEnum CallTail = 4

  toEnum 1 = CallNothrow
  toEnum 2 = CallNoreturn
  toEnum 4 = CallTail
  toEnum unmatched = error ("CallFlag.toEnum: Cannot match " ++ show unmatched)
 

----------------------------------------------------------------------------
-- BaseTypes (these are constants defined in jit-type.c) 
----------------------------------------------------------------------------
void_type = Type (unsafePerformIO (peek voidT'))
foreign import ccall "jit/jit.h &jit_type_void" voidT' :: Ptr (Ptr ())  

sbyte_type = Type (unsafePerformIO (peek sbyteT'))
foreign import ccall "jit/jit.h &jit_type_sbyte" sbyteT' :: Ptr (Ptr ()) 

ubyte_type = Type (unsafePerformIO (peek ubyteT'))
foreign import ccall "jit/jit.h &jit_type_ubyte" ubyteT' :: Ptr (Ptr ()) 

short_type = Type (unsafePerformIO (peek shortT'))
foreign import ccall "jit/jit.h &jit_type_short" shortT' :: Ptr (Ptr ()) 

ushort_type = Type (unsafePerformIO (peek ushortT'))
foreign import ccall "jit/jit.h &jit_type_ushort" ushortT' :: Ptr (Ptr ()) 

int_type = Type (unsafePerformIO (peek intT'))
foreign import ccall "jit/jit.h &jit_type_int" intT' :: Ptr (Ptr ()) 

uint_type = Type (unsafePerformIO (peek uintT'))
foreign import ccall "jit/jit.h &jit_type_uint" uintT' :: Ptr (Ptr ()) 

nint_type = Type (unsafePerformIO (peek nintT'))
foreign import ccall "jit/jit.h &jit_type_nint" nintT' :: Ptr (Ptr ()) 

nuint_type = Type (unsafePerformIO (peek nuintT'))
foreign import ccall "jit/jit.h &jit_type_nuint" nuintT' :: Ptr (Ptr ()) 

long_type = Type (unsafePerformIO (peek longT'))
foreign import ccall "jit/jit.h &jit_type_long" longT' :: Ptr (Ptr ()) 

ulong_type = Type (unsafePerformIO (peek ulongT'))
foreign import ccall "jit/jit.h &jit_type_ulong" ulongT' :: Ptr (Ptr ()) 

float32_type = Type (unsafePerformIO (peek float32T'))
foreign import ccall "jit/jit.h &jit_type_float32" float32T' :: Ptr (Ptr ()) 

float64_type = Type (unsafePerformIO (peek float64T'))
foreign import ccall "jit/jit.h &jit_type_float64" float64T' :: Ptr (Ptr ()) 

void_ptr_type = Type (unsafePerformIO (peek void_ptrT'))
foreign import ccall "jit/jit.h &jit_type_void_ptr" void_ptrT' :: Ptr (Ptr ()) 

----------------------------------------------------------------------------
-- Undefined label 
----------------------------------------------------------------------------

-- TODO: very skeptic to these labels.
--       I do not think I am doing it right. 
getUndefinedLabel :: IO Label
getUndefinedLabel =
  do 
    fptr <- mallocForeignPtr
    let ptr = unsafeForeignPtrToPtr fptr
    poke ptr (0xFFFFFFFF :: CULong)
    return $ Label fptr


----------------------------------------------------------------------------
-- Context  (jit-context.h) 
----------------------------------------------------------------------------
contextCreate = contextCreate' >>= throwOnBadContext 

contextCreate' :: IO (Context)
contextCreate' =
  contextCreate''_ >>= \res ->
  let {res' = Context res} in
  return (res') 

contextDestroy :: Context -> IO ()
contextDestroy a1 =
  let {a1' = fromContext a1} in 
  contextDestroy'_ a1' >>= \res ->
  return () 

-- DONE: figure out what to do with this one (1 means True, 0 means false) 
contextSupportsThreads :: Context -> IO (Bool)
contextSupportsThreads a1 =
  let {a1' = fromContext a1} in 
  contextSupportsThreads'_ a1' >>= \res ->
  let {res' = intToBool res} in
  return (res') 

startBuild :: Context -> IO ()
startBuild a1 =
  let {a1' = fromContext a1} in 
  startBuild'_ a1' >>= \res ->
  return ()
{-# LINE 190 "Libjit/Raw.chs" #-}

endBuild :: Context -> IO ()
endBuild a1 =
  let {a1' = fromContext a1} in 
  endBuild'_ a1' >>= \res ->
  return ()
{-# LINE 193 "Libjit/Raw.chs" #-}

{- 
DONE: jit_context_t jit_context_create(void) JIT_NOTHROW;
DONE: void jit_context_destroy(jit_context_t context) JIT_NOTHROW;
DONE: int jit_context_supports_threads(jit_context_t context) JIT_NOTHROW;
DONE: void jit_context_build_start(jit_context_t context) JIT_NOTHROW;
DONE: void jit_context_build_end(jit_context_t context) JIT_NOTHROW;
void jit_context_set_on_demand_driver(
	jit_context_t context,
	jit_on_demand_driver_func driver) JIT_NOTHROW;
int jit_context_set_meta
	(jit_context_t context, int type, void *data,
	 jit_meta_free_func free_data) JIT_NOTHROW;
int jit_context_set_meta_numeric
	(jit_context_t context, int type, jit_nuint data) JIT_NOTHROW;
void *jit_context_get_meta(jit_context_t context, int type) JIT_NOTHROW;
jit_nuint jit_context_get_meta_numeric
	(jit_context_t context, int type) JIT_NOTHROW;
void jit_context_free_meta(jit_context_t context, int type) JIT_NOTHROW;
-} 

----------------------------------------------------------------------------
-- Functions (jit-function.h) 
----------------------------------------------------------------------------
createTypeSignature :: ABI -> Type -> [Type] -> Int -> Int -> IO (Type)
createTypeSignature a1 a2 a3 a4 a5 =
  let {a1' = cFromEnum a1} in 
  let {a2' = fromType a2} in 
  withTypeArray a3 $ \a3' -> 
  let {a4' = cFromInt a4} in 
  let {a5' = cFromInt a5} in 
  createTypeSignature'_ a1' a2' a3' a4' a5' >>= \res ->
  let {res' = Type res} in
  return (res') 
     
createFunction c t = createFunction' c t >>= throwOnBadFunction 

createFunction' :: Context -> Type -> IO (Function)
createFunction' a1 a2 =
  let {a1' = fromContext a1} in 
  let {a2' = fromType a2} in 
  createFunction''_ a1' a2' >>= \res ->
  let {res' = Function res} in
  return (res') 

getFunctionContext :: Function -> IO (Context)
getFunctionContext a1 =
  let {a1' = fromFunction a1} in 
  getFunctionContext'_ a1' >>= \res ->
  let {res' = Context res} in
  return (res') 

getFunctionSignature :: Function -> IO (Type)
getFunctionSignature a1 =
  let {a1' = fromFunction a1} in 
  getFunctionSignature'_ a1' >>= \res ->
  let {res' = Type res} in
  return (res') 

createNestedFunction c t f = createNestedFunction' c t f >>= throwOnBadFunction 

createNestedFunction' :: Context -> Type -> Function -> IO (Function)
createNestedFunction' a1 a2 a3 =
  let {a1' = fromContext a1} in 
  let {a2' = fromType a2} in 
  let {a3' = fromFunction a3} in 
  createNestedFunction''_ a1' a2' a3' >>= \res ->
  let {res' = Function res} in
  return (res') 

abandonFunction :: Function -> IO ()
abandonFunction a1 =
  let {a1' = fromFunction a1} in 
  abandonFunction'_ a1' >>= \res ->
  return () 

getParam :: Function -> Int -> IO (Value)
getParam a1 a2 =
  let {a1' = fromFunction a1} in 
  let {a2' = cFromInt a2} in 
  getParam'_ a1' a2' >>= \res ->
  let {res' = Value res} in
  return (res')
{-# LINE 249 "Libjit/Raw.chs" #-}

compile :: Function -> IO ()
compile a1 =
  let {a1' = fromFunction a1} in 
  compile'_ a1' >>= \res ->
  return () 

apply :: Function -> [Ptr ()] -> Ptr () -> IO ()
apply a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  withArray a2 $ \a2' -> 
  let {a3' = id a3} in 
  apply'_ a1' a2' a3' >>= \res ->
  return () 

getFunctionEntry :: Function -> IO (Block)
getFunctionEntry a1 =
  let {a1' = fromFunction a1} in 
  getFunctionEntry'_ a1' >>= \res ->
  let {res' = Block res} in
  return (res') 

getFunctionCurrent :: Function -> IO (Block)
getFunctionCurrent a1 =
  let {a1' = fromFunction a1} in 
  getFunctionCurrent'_ a1' >>= \res ->
  let {res' = Block res} in
  return (res') 

isCompiled :: Function -> IO (Bool)
isCompiled a1 =
  let {a1' = fromFunction a1} in 
  isCompiled'_ a1' >>= \res ->
  let {res' = intToBool res} in
  return (res') 

setOptLevel :: Function -> Int -> IO (())
setOptLevel a1 a2 =
  let {a1' = fromFunction a1} in 
  let {a2' = cFromInt a2} in 
  setOptLevel'_ a1' a2' >>= \res ->
  let {res' = id res} in
  return (res') 

getOptLevel :: Function -> IO (Int)
getOptLevel a1 =
  let {a1' = fromFunction a1} in 
  getOptLevel'_ a1' >>= \res ->
  let {res' = cFromInt res} in
  return (res') 


maxOptLevel :: Int
maxOptLevel =
  let {res = maxOptLevel'_} in
  let {res' = cFromInt res} in
  (res') 



{-  
DONE: jit_function_t jit_function_create
	(jit_context_t context, jit_type_t signature) JIT_NOTHROW;
DONE: jit_function_t jit_function_create_nested
	(jit_context_t context, jit_type_t signature,
	 jit_function_t parent) JIT_NOTHROW;
DONE: void jit_function_abandon(jit_function_t func) JIT_NOTHROW;
DONE: jit_context_t jit_function_get_context(jit_function_t func) JIT_NOTHROW;
DONE: jit_type_t jit_function_get_signature(jit_function_t func) JIT_NOTHROW;
int jit_function_set_meta
	(jit_function_t func, int type, void *data,
	 jit_meta_free_func free_data, int build_only) JIT_NOTHROW;
void *jit_function_get_meta(jit_function_t func, int type) JIT_NOTHROW;
void jit_function_free_meta(jit_function_t func, int type) JIT_NOTHROW;
jit_function_t jit_function_next
	(jit_context_t context, jit_function_t prev) JIT_NOTHROW;
jit_function_t jit_function_previous
	(jit_context_t context, jit_function_t prev) JIT_NOTHROW;
DONE: jit_block_t jit_function_get_entry(jit_function_t func) JIT_NOTHROW;
DONE: jit_block_t jit_function_get_current(jit_function_t func) JIT_NOTHROW;
jit_function_t jit_function_get_nested_parent(jit_function_t func) JIT_NOTHROW;
DONE: int jit_function_compile(jit_function_t func) JIT_NOTHROW;
DONE: int jit_function_is_compiled(jit_function_t func) JIT_NOTHROW;
void jit_function_set_recompilable(jit_function_t func) JIT_NOTHROW;
void jit_function_clear_recompilable(jit_function_t func) JIT_NOTHROW;
int jit_function_is_recompilable(jit_function_t func) JIT_NOTHROW;
int jit_function_compile_entry(jit_function_t func, void **entry_point) JIT_NOTHROW;
void jit_function_setup_entry(jit_function_t func, void *entry_point) JIT_NOTHROW;
void *jit_function_to_closure(jit_function_t func) JIT_NOTHROW;
jit_function_t jit_function_from_closure
	(jit_context_t context, void *closure) JIT_NOTHROW;
jit_function_t jit_function_from_pc
	(jit_context_t context, void *pc, void **handler) JIT_NOTHROW;
void *jit_function_to_vtable_pointer(jit_function_t func) JIT_NOTHROW;
jit_function_t jit_function_from_vtable_pointer
	(jit_context_t context, void *vtable_pointer) JIT_NOTHROW;
void jit_function_set_on_demand_compiler
	(jit_function_t func, jit_on_demand_func on_demand) JIT_NOTHROW;
jit_on_demand_func jit_function_get_on_demand_compiler(jit_function_t func) JIT_NOTHROW;
DONE: int jit_function_apply
	(jit_function_t func, void **args, void *return_area);
int jit_function_apply_vararg
	(jit_function_t func, jit_type_t signature, void **args, void *return_area);
DONE: void jit_function_set_optimization_level
	(jit_function_t func, unsigned int level) JIT_NOTHROW;
DONE: unsigned int jit_function_get_optimization_level
	(jit_function_t func) JIT_NOTHROW;
DOME: unsigned int jit_function_get_max_optimization_level(void) JIT_NOTHROW;
jit_label_t jit_function_reserve_label(jit_function_t func) JIT_NOTHROW;
-} 

----------------------------------------------------------------------------
-- Instructions (jit-insn.h)  
----------------------------------------------------------------------------

-- Math 
mul :: Function -> Value -> Value -> IO (Value)
mul a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  mul'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

mul_ovf :: Function -> Value -> Value -> IO (Value)
mul_ovf a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  mul_ovf'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

add :: Function -> Value -> Value -> IO (Value)
add a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  add'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

add_ovf :: Function -> Value -> Value -> IO (Value)
add_ovf a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  add_ovf'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

sub :: Function -> Value -> Value -> IO (Value)
sub a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  sub'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

sub_ovf :: Function -> Value -> Value -> IO (Value)
sub_ovf a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  sub_ovf'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

div :: Function -> Value -> Value -> IO (Value)
div a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  div'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

rem :: Function -> Value -> Value -> IO (Value)
rem a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  rem'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

rem_ieee :: Function -> Value -> Value -> IO (Value)
rem_ieee a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  rem_ieee'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

neg :: Function -> Value -> IO (Value)
neg a1 a2 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  neg'_ a1' a2' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

acos :: Function -> Value -> IO (Value)
acos a1 a2 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  acos'_ a1' a2' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

asin :: Function -> Value -> IO (Value)
asin a1 a2 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  asin'_ a1' a2' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

atan :: Function -> Value -> IO (Value)
atan a1 a2 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  atan'_ a1' a2' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

atan2 :: Function -> Value -> Value -> IO (Value)
atan2 a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  atan2'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

ceil :: Function -> Value -> IO (Value)
ceil a1 a2 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  ceil'_ a1' a2' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

cosh :: Function -> Value -> IO (Value)
cosh a1 a2 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  cosh'_ a1' a2' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

exp :: Function -> Value -> IO (Value)
exp a1 a2 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  exp'_ a1' a2' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

floor :: Function -> Value -> IO (Value)
floor a1 a2 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  floor'_ a1' a2' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

log :: Function -> Value -> IO (Value)
log a1 a2 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  log'_ a1' a2' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

log10 :: Function -> Value -> IO (Value)
log10 a1 a2 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  log10'_ a1' a2' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

pow :: Function -> Value -> Value -> IO (Value)
pow a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  pow'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

rint :: Function -> Value -> IO (Value)
rint a1 a2 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  rint'_ a1' a2' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

round :: Function -> Value -> IO (Value)
round a1 a2 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  round'_ a1' a2' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

sin :: Function -> Value -> IO (Value)
sin a1 a2 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  sin'_ a1' a2' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

sinh :: Function -> Value -> IO (Value)
sinh a1 a2 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  sinh'_ a1' a2' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

sqrt :: Function -> Value -> IO (Value)
sqrt a1 a2 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  sqrt'_ a1' a2' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

tan :: Function -> Value -> IO (Value)
tan a1 a2 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  tan'_ a1' a2' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

tanh :: Function -> Value -> IO (Value)
tanh a1 a2 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  tanh'_ a1' a2' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 


-- Comparisons and boolean 
lt :: Function -> Value -> Value -> IO (Value)
lt a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  lt'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

le :: Function -> Value -> Value -> IO (Value)
le a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  le'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

gt :: Function -> Value -> Value -> IO (Value)
gt a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  gt'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

ge :: Function -> Value -> Value -> IO (Value)
ge a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  ge'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

cmpl :: Function -> Value -> Value -> IO (Value)
cmpl a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  cmpl'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

cmpg :: Function -> Value -> Value -> IO (Value)
cmpg a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  cmpg'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 


eq :: Function -> Value -> Value -> IO (Value)
eq a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  eq'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

ne :: Function -> Value -> Value -> IO (Value)
ne a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  ne'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 


and :: Function -> Value -> Value -> IO (Value)
and a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  and'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

or :: Function -> Value -> Value -> IO (Value)
or a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  or'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

xor :: Function -> Value -> Value -> IO (Value)
xor a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  xor'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

not :: Function -> Value -> IO (Value)
not a1 a2 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  not'_ a1' a2' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

shl :: Function -> Value -> Value -> IO (Value)
shl a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  shl'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

shr :: Function -> Value -> Value -> IO (Value)
shr a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  shr'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

sshr :: Function -> Value -> Value -> IO (Value)
sshr a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  sshr'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 

ushr :: Function -> Value -> Value -> IO (Value)
ushr a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromValue a3} in 
  ushr'_ a1' a2' a3' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 


-- Branch
branch :: Function -> Label -> IO ()
branch a1 a2 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromLabel a2} in 
  branch'_ a1' a2' >>= \res ->
  return ()
{-# LINE 547 "Libjit/Raw.chs" #-}

branchIf :: Function -> Value -> Label -> IO ()
branchIf a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromLabel a3} in 
  branchIf'_ a1' a2' a3' >>= \res ->
  return ()
{-# LINE 552 "Libjit/Raw.chs" #-}

branchIfNot :: Function -> Value -> Label -> IO ()
branchIfNot a1 a2 a3 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  let {a3' = fromLabel a3} in 
  branchIfNot'_ a1' a2' a3' >>= \res ->
  return ()
{-# LINE 557 "Libjit/Raw.chs" #-}

-- Return 
ret :: Function -> Value -> IO ()
ret a1 a2 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromValue a2} in 
  ret'_ a1' a2' >>= \res ->
  return ()  

-- Function calls

callNativeFunction :: Function -> String -> FunPtr a -> Type -> [Value] -> Int -> CallFlag -> IO (Value)
callNativeFunction a1 a2 a3 a4 a5 a6 a7 =
  let {a1' = fromFunction a1} in 
  withCString a2 $ \a2' -> 
  let {a3' = fromFunPtr a3} in 
  let {a4' = fromType a4} in 
  withValueArray a5 $ \a5' -> 
  let {a6' = cFromInt a6} in 
  let {a7' = cFromEnum a7} in 
  callNativeFunction'_ a1' a2' a3' a4' a5' a6' a7' >>= \res ->
  checkedValue res >>= \res' ->
  return (res')
{-# LINE 573 "Libjit/Raw.chs" #-}

callFunction :: Function -> String -> Function -> Type -> [Value] -> Int -> CallFlag -> IO (Value)
callFunction a1 a2 a3 a4 a5 a6 a7 =
  let {a1' = fromFunction a1} in 
  withCString a2 $ \a2' -> 
  let {a3' = fromFunction a3} in 
  let {a4' = fromType a4} in 
  withValueArray a5 $ \a5' -> 
  let {a6' = cFromInt a6} in 
  let {a7' = cFromEnum a7} in 
  callFunction'_ a1' a2' a3' a4' a5' a6' a7' >>= \res ->
  checkedValue res >>= \res' ->
  return (res') 
     

-- Labels
setLabel :: Function -> Label -> IO ()
setLabel a1 a2 =
  let {a1' = fromFunction a1} in 
  let {a2' = fromLabel a2} in 
  setLabel'_ a1' a2' >>= \res ->
  return ()
{-# LINE 588 "Libjit/Raw.chs" #-}

{- 
int jit_insn_get_opcode(jit_insn_t insn) JIT_NOTHROW;
jit_value_t jit_insn_get_dest(jit_insn_t insn) JIT_NOTHROW;
jit_value_t jit_insn_get_value1(jit_insn_t insn) JIT_NOTHROW;
jit_value_t jit_insn_get_value2(jit_insn_t insn) JIT_NOTHROW;
jit_label_t jit_insn_get_label(jit_insn_t insn) JIT_NOTHROW;
jit_function_t jit_insn_get_function(jit_insn_t insn) JIT_NOTHROW;
void *jit_insn_get_native(jit_insn_t insn) JIT_NOTHROW;
const char *jit_insn_get_name(jit_insn_t insn) JIT_NOTHROW;
jit_type_t jit_insn_get_signature(jit_insn_t insn) JIT_NOTHROW;
int jit_insn_dest_is_value(jit_insn_t insn) JIT_NOTHROW;

DONE: int jit_insn_label(jit_function_t func, jit_label_t *label) JIT_NOTHROW;
int jit_insn_new_block(jit_function_t func) JIT_NOTHROW;
jit_value_t jit_insn_load(jit_function_t func, jit_value_t value) JIT_NOTHROW;
jit_value_t jit_insn_dup(jit_function_t func, jit_value_t value) JIT_NOTHROW;
jit_value_t jit_insn_load_small
	(jit_function_t func, jit_value_t value) JIT_NOTHROW;
int jit_insn_store
	(jit_function_t func, jit_value_t dest, jit_value_t value) JIT_NOTHROW;
jit_value_t jit_insn_load_relative
	(jit_function_t func, jit_value_t value,
	 jit_nint offset, jit_type_t type) JIT_NOTHROW;
int jit_insn_store_relative
	(jit_function_t func, jit_value_t dest,
	 jit_nint offset, jit_value_t value) JIT_NOTHROW;
jit_value_t jit_insn_add_relative
	(jit_function_t func, jit_value_t value, jit_nint offset) JIT_NOTHROW;
jit_value_t jit_insn_load_elem
	(jit_function_t func, jit_value_t base_addr,
	 jit_value_t index, jit_type_t elem_type) JIT_NOTHROW;
jit_value_t jit_insn_load_elem_address
	(jit_function_t func, jit_value_t base_addr,
	 jit_value_t index, jit_type_t elem_type) JIT_NOTHROW;
int jit_insn_store_elem
	(jit_function_t func, jit_value_t base_addr,
	 jit_value_t index, jit_value_t value) JIT_NOTHROW;
int jit_insn_check_null(jit_function_t func, jit_value_t value) JIT_NOTHROW;

DONE: jit_value_t jit_insn_add
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_add_ovf
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_sub
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_sub_ovf
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_mul
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_mul_ovf
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_div
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_rem
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_rem_ieee
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_neg
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
DONE: jit_value_t jit_insn_and
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_or
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_xor
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_not
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
DONE: jit_value_t jit_insn_shl
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DOME: jit_value_t jit_insn_shr
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_ushr
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_sshr
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_eq
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_ne
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_lt
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_le
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_gt
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_ge
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_cmpl
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_cmpg
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
jit_value_t jit_insn_to_bool
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
jit_value_t jit_insn_to_not_bool
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
DONE: jit_value_t jit_insn_acos
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
DONE: jit_value_t jit_insn_asin
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
DONE: jit_value_t jit_insn_atan
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
DONE: jit_value_t jit_insn_atan2
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_ceil
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
DONE: jit_value_t jit_insn_cos
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
DONE: jit_value_t jit_insn_cosh
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
DONE: jit_value_t jit_insn_exp
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
DONE: jit_value_t jit_insn_floor
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
DONE: jit_value_t jit_insn_log
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
DONE: jit_value_t jit_insn_log10
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
DONE: jit_value_t jit_insn_pow
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
DONE: jit_value_t jit_insn_rint
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
DONE: jit_value_t jit_insn_round
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
DONE: jit_value_t jit_insn_sin
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
DONE: jit_value_t jit_insn_sinh
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
DONE: jit_value_t jit_insn_sqrt
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
DONE: jit_value_t jit_insn_tan
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
DONE: jit_value_t jit_insn_tanh
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
jit_value_t jit_insn_is_nan
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
jit_value_t jit_insn_is_finite
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
jit_value_t jit_insn_is_inf
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
jit_value_t jit_insn_abs
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
jit_value_t jit_insn_min
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
jit_value_t jit_insn_max
	(jit_function_t func, jit_value_t value1, jit_value_t value2) JIT_NOTHROW;
jit_value_t jit_insn_sign
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
DONE: int jit_insn_branch
	(jit_function_t func, jit_label_t *label) JIT_NOTHROW;
DONE: int jit_insn_branch_if
	(jit_function_t func, jit_value_t value, jit_label_t *label) JIT_NOTHROW;
DONE: int jit_insn_branch_if_not
	(jit_function_t func, jit_value_t value, jit_label_t *label) JIT_NOTHROW;
int jit_insn_jump_table
	(jit_function_t func, jit_value_t value,
	 jit_label_t *labels, unsigned int num_labels) JIT_NOTHROW;
jit_value_t jit_insn_address_of
	(jit_function_t func, jit_value_t value1) JIT_NOTHROW;
jit_value_t jit_insn_address_of_label
	(jit_function_t func, jit_label_t *label) JIT_NOTHROW;
jit_value_t jit_insn_convert
	(jit_function_t func, jit_value_t value,
	 jit_type_t type, int overflow_check) JIT_NOTHROW;

DONE: jit_value_t jit_insn_call
	(jit_function_t func, const char *name,
	 jit_function_t jit_func, jit_type_t signature,
	 jit_value_t *args, unsigned int num_args, int flags) JIT_NOTHROW;
jit_value_t jit_insn_call_indirect
	(jit_function_t func, jit_value_t value, jit_type_t signature,
	 jit_value_t *args, unsigned int num_args, int flags) JIT_NOTHROW;
jit_value_t jit_insn_call_indirect_vtable
	(jit_function_t func, jit_value_t value, jit_type_t signature,
	 jit_value_t *args, unsigned int num_args, int flags) JIT_NOTHROW;
DONE: jit_value_t jit_insn_call_native
	(jit_function_t func, const char *name,
	 void *native_func, jit_type_t signature,
	 jit_value_t *args, unsigned int num_args, int flags) JIT_NOTHROW;
jit_value_t jit_insn_call_intrinsic
	(jit_function_t func, const char *name, void *intrinsic_func,
	 const jit_intrinsic_descr_t *descriptor,
	 jit_value_t arg1, jit_value_t arg2) JIT_NOTHROW;
int jit_insn_incoming_reg
	(jit_function_t func, jit_value_t value, int reg) JIT_NOTHROW;
int jit_insn_incoming_frame_posn
	(jit_function_t func, jit_value_t value, jit_nint frame_offset) JIT_NOTHROW;
int jit_insn_outgoing_reg
	(jit_function_t func, jit_value_t value, int reg) JIT_NOTHROW;
int jit_insn_outgoing_frame_posn
	(jit_function_t func, jit_value_t value, jit_nint frame_offset) JIT_NOTHROW;
int jit_insn_return_reg
	(jit_function_t func, jit_value_t value, int reg) JIT_NOTHROW;
int jit_insn_setup_for_nested
	(jit_function_t func, int nested_level, int reg) JIT_NOTHROW;
int jit_insn_flush_struct(jit_function_t func, jit_value_t value) JIT_NOTHROW;
jit_value_t jit_insn_import
	(jit_function_t func, jit_value_t value) JIT_NOTHROW;
int jit_insn_push(jit_function_t func, jit_value_t value) JIT_NOTHROW;
int jit_insn_push_ptr
	(jit_function_t func, jit_value_t value, jit_type_t type) JIT_NOTHROW;
int jit_insn_set_param
	(jit_function_t func, jit_value_t value, jit_nint offset) JIT_NOTHROW;
int jit_insn_set_param_ptr
	(jit_function_t func, jit_value_t value, jit_type_t type,
	 jit_nint offset) JIT_NOTHROW;
int jit_insn_push_return_area_ptr(jit_function_t func) JIT_NOTHROW;
int jit_insn_pop_stack(jit_function_t func, jit_nint num_items) JIT_NOTHROW;
int jit_insn_defer_pop_stack
	(jit_function_t func, jit_nint num_items) JIT_NOTHROW;
int jit_insn_flush_defer_pop
	(jit_function_t func, jit_nint num_items) JIT_NOTHROW;
DONE: int jit_insn_return(jit_function_t func, jit_value_t value) JIT_NOTHROW;
int jit_insn_return_ptr
	(jit_function_t func, jit_value_t value, jit_type_t type) JIT_NOTHROW;
int jit_insn_default_return(jit_function_t func) JIT_NOTHROW;
int jit_insn_throw(jit_function_t func, jit_value_t value) JIT_NOTHROW;
jit_value_t jit_insn_get_call_stack(jit_function_t func) JIT_NOTHROW;

jit_value_t jit_insn_thrown_exception(jit_function_t func) JIT_NOTHROW;
int jit_insn_uses_catcher(jit_function_t func) JIT_NOTHROW;
jit_value_t jit_insn_start_catcher(jit_function_t func) JIT_NOTHROW;
int jit_insn_branch_if_pc_not_in_range
	(jit_function_t func, jit_label_t start_label,
	 jit_label_t end_label, jit_label_t *label) JIT_NOTHROW;
int jit_insn_rethrow_unhandled(jit_function_t func) JIT_NOTHROW;
int jit_insn_start_finally
	(jit_function_t func, jit_label_t *finally_label) JIT_NOTHROW;
int jit_insn_return_from_finally(jit_function_t func) JIT_NOTHROW;
int jit_insn_call_finally
	(jit_function_t func, jit_label_t *finally_label) JIT_NOTHROW;
jit_value_t jit_insn_start_filter
	(jit_function_t func, jit_label_t *label, jit_type_t type) JIT_NOTHROW;
int jit_insn_return_from_filter
	(jit_function_t func, jit_value_t value) JIT_NOTHROW;
jit_value_t jit_insn_call_filter
	(jit_function_t func, jit_label_t *label,
	 jit_value_t value, jit_type_t type) JIT_NOTHROW;

int jit_insn_memcpy
	(jit_function_t func, jit_value_t dest,
	 jit_value_t src, jit_value_t size) JIT_NOTHROW;
int jit_insn_memmove
	(jit_function_t func, jit_value_t dest,
	 jit_value_t src, jit_value_t size) JIT_NOTHROW;
int jit_insn_memset
	(jit_function_t func, jit_value_t dest,
	 jit_value_t value, jit_value_t size) JIT_NOTHROW;
jit_value_t jit_insn_alloca
	(jit_function_t func, jit_value_t size) JIT_NOTHROW;

int jit_insn_move_blocks_to_end
	(jit_function_t func, jit_label_t from_label, jit_label_t to_label)
		JIT_NOTHROW;
int jit_insn_move_blocks_to_start
	(jit_function_t func, jit_label_t from_label, jit_label_t to_label)
		JIT_NOTHROW;

int jit_insn_mark_offset
	(jit_function_t func, jit_int offset) JIT_NOTHROW;
int jit_insn_mark_breakpoint
	(jit_function_t func, jit_nint data1, jit_nint data2) JIT_NOTHROW;
int jit_insn_mark_breakpoint_variable
	(jit_function_t func, jit_value_t data1, jit_value_t data2) JIT_NOTHROW;

void jit_insn_iter_init(jit_insn_iter_t *iter, jit_block_t block) JIT_NOTHROW;
void jit_insn_iter_init_last
	(jit_insn_iter_t *iter, jit_block_t block) JIT_NOTHROW;
jit_insn_t jit_insn_iter_next(jit_insn_iter_t *iter) JIT_NOTHROW;
jit_insn_t jit_insn_iter_previous(jit_insn_iter_t *iter) JIT_NOTHROW;
-} 

foreign import ccall unsafe "Libjit/Raw.chs.h jit_context_create"
  contextCreate''_ :: (IO (Ptr ()))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_context_destroy"
  contextDestroy'_ :: ((Ptr ()) -> (IO ()))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_context_supports_threads"
  contextSupportsThreads'_ :: ((Ptr ()) -> (IO CInt))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_context_build_start"
  startBuild'_ :: ((Ptr ()) -> (IO ()))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_context_build_end"
  endBuild'_ :: ((Ptr ()) -> (IO ()))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_type_create_signature"
  createTypeSignature'_ :: (CInt -> ((Ptr ()) -> ((Ptr (Ptr ())) -> (CUInt -> (CInt -> (IO (Ptr ())))))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_function_create"
  createFunction''_ :: ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ()))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_function_get_context"
  getFunctionContext'_ :: ((Ptr ()) -> (IO (Ptr ())))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_function_get_signature"
  getFunctionSignature'_ :: ((Ptr ()) -> (IO (Ptr ())))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_function_create_nested"
  createNestedFunction''_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_function_abandon"
  abandonFunction'_ :: ((Ptr ()) -> (IO ()))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_value_get_param"
  getParam'_ :: ((Ptr ()) -> (CUInt -> (IO (Ptr ()))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_function_compile"
  compile'_ :: ((Ptr ()) -> (IO CInt))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_function_apply"
  apply'_ :: ((Ptr ()) -> ((Ptr (Ptr ())) -> ((Ptr ()) -> (IO CInt))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_function_get_entry"
  getFunctionEntry'_ :: ((Ptr ()) -> (IO (Ptr ())))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_function_get_current"
  getFunctionCurrent'_ :: ((Ptr ()) -> (IO (Ptr ())))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_function_is_compiled"
  isCompiled'_ :: ((Ptr ()) -> (IO CInt))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_function_set_optimization_level"
  setOptLevel'_ :: ((Ptr ()) -> (CUInt -> (IO ())))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_function_get_optimization_level"
  getOptLevel'_ :: ((Ptr ()) -> (IO CUInt))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_function_get_max_optimization_level"
  maxOptLevel'_ :: CUInt

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_mul"
  mul'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_mul_ovf"
  mul_ovf'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_add"
  add'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_add_ovf"
  add_ovf'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_sub"
  sub'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_sub_ovf"
  sub_ovf'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_div"
  div'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_rem"
  rem'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_rem_ieee"
  rem_ieee'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_neg"
  neg'_ :: ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ()))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_acos"
  acos'_ :: ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ()))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_asin"
  asin'_ :: ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ()))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_atan"
  atan'_ :: ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ()))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_atan2"
  atan2'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_ceil"
  ceil'_ :: ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ()))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_cos"
  cosh'_ :: ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ()))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_exp"
  exp'_ :: ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ()))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_floor"
  floor'_ :: ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ()))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_log"
  log'_ :: ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ()))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_log10"
  log10'_ :: ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ()))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_pow"
  pow'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_rint"
  rint'_ :: ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ()))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_round"
  round'_ :: ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ()))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_sin"
  sin'_ :: ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ()))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_sinh"
  sinh'_ :: ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ()))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_sqrt"
  sqrt'_ :: ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ()))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_tan"
  tan'_ :: ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ()))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_tanh"
  tanh'_ :: ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ()))))

foreign import ccall safe "Libjit/Raw.chs.h jit_insn_lt"
  lt'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall safe "Libjit/Raw.chs.h jit_insn_le"
  le'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall safe "Libjit/Raw.chs.h jit_insn_gt"
  gt'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall safe "Libjit/Raw.chs.h jit_insn_ge"
  ge'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall safe "Libjit/Raw.chs.h jit_insn_cmpl"
  cmpl'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall safe "Libjit/Raw.chs.h jit_insn_cmpg"
  cmpg'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall safe "Libjit/Raw.chs.h jit_insn_eq"
  eq'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall safe "Libjit/Raw.chs.h jit_insn_ne"
  ne'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall safe "Libjit/Raw.chs.h jit_insn_and"
  and'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall safe "Libjit/Raw.chs.h jit_insn_or"
  or'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall safe "Libjit/Raw.chs.h jit_insn_xor"
  xor'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall safe "Libjit/Raw.chs.h jit_insn_not"
  not'_ :: ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ()))))

foreign import ccall safe "Libjit/Raw.chs.h jit_insn_shl"
  shl'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall safe "Libjit/Raw.chs.h jit_insn_shr"
  shr'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall safe "Libjit/Raw.chs.h jit_insn_sshr"
  sshr'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall safe "Libjit/Raw.chs.h jit_insn_ushr"
  ushr'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO (Ptr ())))))

foreign import ccall safe "Libjit/Raw.chs.h jit_insn_branch"
  branch'_ :: ((Ptr ()) -> ((Ptr CULong) -> (IO CInt)))

foreign import ccall safe "Libjit/Raw.chs.h jit_insn_branch_if"
  branchIf'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr CULong) -> (IO CInt))))

foreign import ccall safe "Libjit/Raw.chs.h jit_insn_branch_if_not"
  branchIfNot'_ :: ((Ptr ()) -> ((Ptr ()) -> ((Ptr CULong) -> (IO CInt))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_return"
  ret'_ :: ((Ptr ()) -> ((Ptr ()) -> (IO CInt)))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_call_native"
  callNativeFunction'_ :: ((Ptr ()) -> ((Ptr CChar) -> ((Ptr ()) -> ((Ptr ()) -> ((Ptr (Ptr ())) -> (CUInt -> (CInt -> (IO (Ptr ())))))))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_call"
  callFunction'_ :: ((Ptr ()) -> ((Ptr CChar) -> ((Ptr ()) -> ((Ptr ()) -> ((Ptr (Ptr ())) -> (CUInt -> (CInt -> (IO (Ptr ())))))))))

foreign import ccall unsafe "Libjit/Raw.chs.h jit_insn_label"
  setLabel'_ :: ((Ptr ()) -> ((Ptr CULong) -> (IO CInt)))
